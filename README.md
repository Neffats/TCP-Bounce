# TCP-Bounce

Simple client and server based on the article below.

https://firstmonday.org/ojs/index.php/fm/article/view/528/449 

TL;DR - TCP header fields are relative, they don't need to be initialised, so you can set it to whatever you want.

Currently only sends text in blocks of 3 letters per packet.

## Usage

### Server

The server will listen on a port specified by the user. The first packet of a message is sent to the server on this port, we call this packet the init packet. It will tell the server which port the message will be sent to. The server will spawn a thread to listen on the port specified in the init packet. This is how the server manages message from different clients. 

When the server receives a packet it will send a reset packet to the source address. This is so the server used to respect the servers the client bounces off. We don't want to cause servers to keep unestablished sockets open for no reason.

The TCPBounceServer uses decorators to handle the received packets, similar to the way flask does things. User must decorate their function with the block_handler() decorator function:

```python
import TCPBounceServer
import logging
import datetime



logging.getLogger().setLevel(logging.NOTSET)
# Set the servers main listener port to 2003.
bounce_server = TCPBounceServer.Server(listen_port=2003)


@bounce_server.block_handler()
def write_msg(package):
  # Check if the message checksum generated by the client matches the server checksum.
	if package.rcv_checksum == package.gen_checksum:
		with open("message.txt", "a") as f:
			f.write(f"{datetime.datetime.now()}: {package.payload}\n")

	else:
		logging.error("Checksums didn't match. Not writing to file.")


if __name__ == "__main__":
	bounce_server.run()
```

This will pass a Package() object to the function which contains the message type, message, the checksum received and the checksum the server generated. The server provides both checksums so that the user can decide how to hanlde mismatching messages. 

## Note
This gets very easily defeated by things like NAT, anti-spoofing and stateful firewalls. 

